<html><head><meta charset="utf-8"></head><script src="pythons.js" type=module id="site" data-src="fs,vtx,gui" async defer>#<!--
import sys
import platform
import asyncio
from pathlib import Path

sys.argv = PyConfig.pop("argv", [])

if window.location.href.find('localhost')>0:
    PyConfig["dev_mode"] = 1

#print(json.dumps(PyConfig, sort_keys=True, indent=4))



from types import SimpleNamespace
import builtins
builtins.PyConfig = SimpleNamespace(**PyConfig)
del PyConfig

if PyConfig.dev_mode>0:
    PyConfig.pkg_indexes = ['http://localhost:8000/archives/repo/']
else:
    PyConfig.pkg_indexes = ['https://pygame-web.github.io/archives/repo/']




import inspect
import sysconfig
import importlib


import os
# set correct umask ( emscripten default is 0 )
os.umask(0o022) # already done in aio.toplevel

# ok
# import packaging, pyparsing, cycler, kiwisolver, PIL, dateutil, pytz, numpy, matplotlib

async def pv(track, prefix = '', suffix = '', decimals = 1, length = 100, fill = 'â–ˆ', printEnd = "\r"):

    # Progress Bar Printing Function
    def print_pg_bar(total, iteration):
        percent = ("{0:." + str(decimals) + "f}").format(100 * (iteration / float(total)))
        filledLength = int(length * iteration // total)
        bar = fill * filledLength + '-' * (length - filledLength)
        print(f'\r{prefix} |{bar}| {percent}% {suffix}', end = printEnd)

    # Update Progress Bar
    while True:
        print_pg_bar(track.len or 100, track.pos or 0)
        if track.avail:
            break
        await asyncio.sleep(.02)

    # Print New Line on Complete
    print()


from aio.toplevel import AsyncInteractiveConsole, get_repo_pkg

def importer(want, ex=None, resume=None):
    global PyConfig

    #print("getting from repo : ", PyConfig.pkg_indexes )

    for repo in PyConfig.pkg_repolist:
        if want in repo:
            if PyConfig.dev_mode>0:
                pkg_url = f"{PyConfig.pkg_indexes[0]}{repo[want]}"
            else:
                pkg_url = f"{repo['-CDN-']}{repo[want]}"


            pkg_file =  f"/tmp/{repo[want].rsplit('/',1)[-1]}"

            cfg = {
                "io": "url",
                "type":"fs",
                "path" : pkg_file
            }
            print("pkg :", pkg_url, "=>", pkg_file)

            track = platform.window.MM.prepare(pkg_url, json.dumps(cfg))

            async def get_pkg(track):
                await pv(track)

                return await get_repo_pkg(pkg_file, want, resume, ex)

            return get_pkg(track)
        else:
            print(f"PKG NOT FOUND : {want=}, {resume=}, {ex=}")
    return asyncio.sleep(0)






class tl_importer:

    repos = []
    mapping = {}
    may_need = []
    ignore = ["distutils", "installer", "sysconfig"]
    ignore += ["python-dateutil", "matplotlib-pyodide"]
    # ???
    ignore += [ "pillow", "fonttools"]


    from pathlib import Path

    dl_cdn = Path(PyConfig.pkg_indexes[0])
    cdn = Path(dl_cdn)

    repodata = "repodata.json"

    print(f"121 CDN: {cdn}")

    @classmethod
    def code_imports(cls, code=""):

        import platform
        import json

        def scan_imports(code, filename):
            nonlocal cls
            ast = __import__("ast")
            root = ast.parse(code, filename)
            required = []
            for node in ast.walk(root):
                if isinstance(node, ast.Import):
                    module = []
                elif isinstance(node, ast.ImportFrom):
                    module = node.module.split(".")
                else:
                    continue

                for n in node.names:
                    if len(module):
                        mod = module[0] or n.name.split(".")[0]
                    else:
                        mod = n.name.split(".")[0]

                    if mod in cls.ignore:
                        continue

                    if mod in sys.modules:
                        continue

                    try:
                        __import__(mod)
                    except (ModuleNotFoundError, ImportError):
                        required.append(mod)
            return required

        if code == "":
            with open(__file__) as fcode:
                # assert code == fcode.read()
                cls.may_need.extend(scan_imports(fcode.read(), __file__))
        else:
            cls.may_need.extend(scan_imports(code, "<stdin>"))

    @classmethod
    def imports(cls, *mods, lvl=0, wants=[]):
        unseen = False
        for mod in mods:
            for dep in cls.repos[0]["packages"].get(mod, {}).get("depends", []):
                if mod in sys.modules:
                    continue

                if (not dep in wants) and (not dep in cls.ignore):
                    unseen = True
                    wants.insert(0, dep)

        if lvl < 3 and unseen:
            cls.imports(*wants, lvl=lvl + 1, wants=wants)

        if not lvl:
            for dep in mods:
                if mod in sys.modules:
                    continue

                if (not dep in wants) and (not dep in cls.ignore):
                    wants.append(dep)
        return wants



    @classmethod
    async def async_imports(cls, *wanted):
#        # using pyodide repodata
#        async def pkg_install(*packages):
#            nonlocal cls
#            import sys
#            import sysconfig
#            import importlib

#            refresh = False
#            for pkg in packages:
#                pkg_info = cls.repos[0]["packages"].get(pkg, None)

#                if pkg_info is None:
#                    pdb(f'144: package "{pkg}" not found in repodata')
#                    continue

#                file_name = pkg_info.get("file_name", "")
#                valid = False
#                if file_name:
#                    pkg_file = f"/tmp/{file_name}"

#                    async with platform.fopen(
#                        cls.dl_cdn / file_name, "rb"
#                    ) as source:
#                        source.rename_to(pkg_file)
#                        for hex in shell.sha256sum(pkg_file):
#                            expected = hex.split(" ", 1)[0].lower()
#                            maybe = pkg_info.get("sha256", "").lower()
#                            if maybe and (maybe != expected):
#                                pdb(
#                                    f"158: {pkg} download to {pkg_file} corrupt",
#                                    pkg_info.get("sha256", ""),
#                                    expected,
#                                )
#                                break
#                        else:
#                            valid = True
#                            refresh = True
#                else:
#                    pdb(f'144: package "{pkg}" invalid in repodata')
#                    continue

#            # call aio.toplevel.install
#            aio.toplevel.install(pkg_file, sysconfig.get_paths() )



        # init dep solver.

        if not len(cls.repos):
            for cdn in PyConfig.pkg_indexes:
                async with platform.fopen(Path(cdn) / cls.repodata) as source:
                    cls.repos.append(json.loads(source.read()))

            #print(json.dumps(cls.repos[0]["packages"], sort_keys=True, indent=4))

            print("referenced packages :", len(cls.repos[0]["packages"]))

        all = cls.imports(*wanted)
        if 'numpy' in all:
            print("254: importing numpy first")
            await importer('numpy')
            import numpy
            all.remove('numpy')


        for req in all:
            if req == "python-dateutil":
                req= "dateutil"

            if req == "pillow":
                req= "PIL"

            if req in cls.ignore or req in sys.modules:
                continue
            #await asyncio.sleep(0.02)
            await importer(req)
            #sys.modules[req] = __import__(req)


        #await pkg_install(*imports(*wanted))













# screen pixels (real, hardware)
WIDTH=1024
HEIGHT=600

# reference/idealized screen pixels
REFX = 1980
REFY = 1080


def u(real, ref, v):
    if abs(v)<0.9999999:
        result = int( (float(real)/100.0) * (v*1000))
        if v<0:
            return real-result
        return result
    return int( (real/ref) * v )

def ux(*argv):
    global WIDTH, REFX
    acc = 0
    for v in argv:
        acc += u(WIDTH, REFX, v)
    return acc

def uy(*argv):
    global HEIGHT, REFY
    acc = 0
    for v in argv:
        acc += u(HEIGHT, REFY, v)
    return acc







if sys.platform in ("emscripten","wasi",):

    platform.window.python.is_ready = True

    log =  platform.console

    try:
        platform.document.body.style.background = "#7f7f7f"
        import pygame
        screen = pygame.display.set_mode([ux(.100),uy(.100)], pygame.SRCALPHA, 32)
        screen.set_colorkey( (0,0,0,0), pygame.RLEACCEL )
        screen.fill( (0,0,0,0) )

    except Exception as _:
        pygame = False
        sys.print_exception(_)
        log.error("cannot load pygame and clear canvas")




    async def sitecustomize():
        global PyConfig, con

        # reset term
        # ESC("c")



        class VFS:
            from pathlib import Path
            script = Path(PyConfig.run_filename) # or sys.argv[0]
            if script.suffix.lower() == ".py":
                print("Loading:", script )

        PyConfig.pkg_repolist = []
        abitag = f"cp{sys.version_info.major}{sys.version_info.minor}"

        for repo in PyConfig.pkg_indexes:
            async with fopen(f'{repo}index.json', 'r') as index:
                try:
                    data = index.read().replace("<abi>",abitag)
                    repo = json.loads(data)
                except:
                    pdb(f"{repo}: malformed json index {data}")
                    continue
                PyConfig.pkg_repolist.append( repo )


        async_console = AsyncInteractiveConsole(
                globals(),
                shell=shell,
                importer=importer,
            ).interact()

        aio.create_task(async_console)


        #wants = "packaging, pyparsing, cycler, kiwisolver, PIL, dateutil, pytz, numpy".split(', ')
        wants = ["numpy"]
        if 0:
            await tl_importer.async_imports(*wants)
            import numpy

        if 1:
            await asyncio.sleep(1)
            await tl_importer.async_imports("matplotlib")


        if 1: #not pygame:
            return

        rng = 10 # resolution of progress bar
        slot = ux(.060)/rng # 60%

        async def compose(delay=0):
            global screen
            pygame.display.update()
            platform.window.chromakey(None, *screen.get_colorkey(), 40)
            await asyncio.sleep(delay)

        for i in range(rng):
            marginx = ux(.020) # 20%
            marginy = uy(.045) # 45%
            pygame.draw.rect(screen,(10,10,10),( marginx-ux(10), marginy-uy(10), (rng*slot)+ux(20), uy(110) ) )
            pygame.draw.rect(screen,(0,255,0), ( marginx, marginy, (1+i)*slot, uy(90)) )
            await compose(1)



    asyncio.run(sitecustomize())





# --></script></html>










